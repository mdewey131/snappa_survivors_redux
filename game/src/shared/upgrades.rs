use crate::shared::{
    GameMainChannel, game_kinds::is_single_player, players::Player, states::InGameState,
    stats::xp::LevelUpMessage, weapons::WeaponKind,
};
use bevy::prelude::*;
use lightyear::prelude::*;
use serde::{Deserialize, Serialize};

pub struct TempUpgradePlugin;
impl Plugin for TempUpgradePlugin {
    fn build(&self, app: &mut App) {
        app.register_message::<ServerMoveToUpgradesMessage>()
            .add_direction(NetworkDirection::ServerToClient);
        app.register_component::<UpgradeOptions>().add_prediction();

        // TODO: Move this to client and server delineated plugins
        app.add_systems(
            Update,
            (
                ((
                    spawn_upgrade_choices.pipe(server_send_upgrade_message_to_client),
                    client_move_to_selecting_upgrades_on_server_message,
                )
                    .run_if(not(is_single_player))),
                (spawn_upgrade_choices
                    .pipe(client_move_to_selecting_upgrades_state)
                    .run_if(is_single_player)),
            ),
        );
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ServerMoveToUpgradesMessage;

/// This component is added on to player entities.
/// We do it in this way so that we can know which ones to render on each player's screen,
/// and becuase it makes reasoning about which ones are controlled vs. not unnecessary,
/// which is what we want since this can exist in SP or MP
#[derive(Component, Reflect, Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]
pub struct UpgradeOptions {
    pub options: [Upgrade; 3],
    selected: Option<usize>,
}

/// The component that marks a given upgrade.
/// Players will be offered one of three choices for them
/// to take, which will boost their stats depending on
/// the upgrade kind (which provides base values),
/// and the rarity (which modifies those values)
#[derive(Component, Reflect, Debug, Clone, Copy, Serialize, Deserialize, Default, PartialEq)]
pub struct Upgrade {
    pub kind: UpgradeKind,
    pub rarity: UpgradeRarity,
    pub level: u8,
}

#[derive(Component, Default, Reflect, Debug, Clone, Serialize, Deserialize)]
pub struct PlayerUpgradeSlots {
    pub weapons: Vec<WeaponKind>,
    pub stats: Vec<StatUpgradeKind>,
}

#[derive(Reflect, Debug, Clone, Copy, Serialize, Deserialize, Default, PartialEq)]
pub enum UpgradeRarity {
    #[default]
    Common,
    Rare,
    Epic,
    Legendary,
}

#[derive(Reflect, Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum UpgradeKind {
    UpgradeWeapon(WeaponKind),
    UpgradeStat(StatUpgradeKind),
}
impl Default for UpgradeKind {
    fn default() -> Self {
        Self::UpgradeStat(StatUpgradeKind::default())
    }
}

#[derive(Reflect, Debug, Clone, Copy, Serialize, Deserialize, Default, PartialEq)]
pub enum StatUpgradeKind {
    #[default]
    DEFAULT_STAT,
    Armor,
    CritChance,
    CDR,
    Damage,
    EffDuration,
    EffSize,
    Evasion,
    MaxHealth,
    HealthRegen,
    Luck,
    MoveSpeed,
    PickupRadius,
    ProjectileCount,
    Shield,
    Thorns,
    XPGain,
}

/// The specific portion of the upgrades process that reads level up messages and spawns choices
///
/// This is to be run on the server and received by the client when we're in multiplayer,
/// but its meant to be generated by the client when we're in single player mode
///
/// This returns a result, which we mostly do to be able to pipe this into other functions that
/// do different things depending on where we are (send message from server in MP, move to selecting state on client)
pub fn spawn_upgrade_choices(
    mut reader: MessageReader<LevelUpMessage>,
    mut commands: Commands,
    q_player: Query<Entity, With<Player>>,
) -> Result<(), BevyError> {
    if let Some(m) = reader.read().next() {
        for p_ent in &q_player {
            let mut options = [Upgrade::default(); 3];
            for i in (0..3) {
                options[i] = Upgrade {
                    kind: UpgradeKind::UpgradeStat(StatUpgradeKind::MaxHealth),
                    rarity: UpgradeRarity::Common,
                    level: 1,
                };
            }
            let comp_options = UpgradeOptions {
                options,
                selected: None,
            };
            commands.entity(p_ent).insert(comp_options);
        }
        Ok(())
    } else {
        Err(BevyError::from("no_op"))
    }
}

/// Run on the server. We expect the values of the selection upgrades to be piped
/// in because we need to attach networking components
pub fn server_send_upgrade_message_to_client(
    incoming: In<Result<(), BevyError>>,
    mut next: ResMut<NextState<InGameState>>,
    mut q_messages: Single<&mut MessageSender<ServerMoveToUpgradesMessage>>,
) {
    // Guard clause
    if incoming.0.is_err() {
        return;
    }
    q_messages.send::<GameMainChannel>(ServerMoveToUpgradesMessage);
    next.set(InGameState::SelectingUpgrades)
}

pub fn client_move_to_selecting_upgrades_state(
    incoming: In<Result<(), BevyError>>,
    mut next: ResMut<NextState<InGameState>>,
) {
    if incoming.0.is_err() {
        return;
    }
    next.set(InGameState::SelectingUpgrades)
}

pub fn client_move_to_selecting_upgrades_on_server_message(
    mut next: ResMut<NextState<InGameState>>,
    mut q_rec: Single<&mut MessageReceiver<ServerMoveToUpgradesMessage>>,
) {
    for mut _m in q_rec.receive() {
        next.set(InGameState::SelectingUpgrades);
        break;
    }
}
